import { CHAR_ADVANCE, SIMPLE_FONT, START_GCODE_RAW, END_GCODE_RAW } from './constants.js'
import {
  linspace, filamentArea, ePerMmLine, g1Move, applyPlaceholders,
  retractLinesDoe, retractLinesAvg
} from './helpers.js'

export function generateGcodeFromForm(formState) {
  const cfg = {
    // basic form values
    BED_SIZE_X: formState.bedX,
    BED_SIZE_Y: formState.bedY,
    MIN_RETRACT_DIST: formState.minDist,
    MAX_RETRACT_DIST: formState.maxDist,
    MIN_RETRACT_SPEED: formState.minSpeed,
    MAX_RETRACT_SPEED: formState.maxSpeed,
    ROWS: formState.rows,
    COLS: formState.cols,
    LINES_PER_PARAM: formState.linesPerParam,
    NUM_DOE_LAYERS: formState.numLayers,
    SEGMENT_LENGTH: formState.segLen,
    TRAVEL_LENGTH: formState.travelLen,
    Z_HOP: formState.zHop || 0,
    FLOW_FACTOR: formState.flowFactor,
    BED_TEMP: formState.bedTemp,
    HOTEND_TEMP: formState.hotendTemp,
    FIRST_LAYER_FAN_SPEED: formState.firstLayerFanSpeed,
    FAN_SPEED: formState.fanSpeed,
    FIRST_LAYER_SPEED: formState.firstLayerSpeed,
    PRINT_SPEED: formState.printSpeed,
    TRAVEL_SPEED: formState.travelSpeed,
    // accelerations (mm/s^2)
    PRINT_ACCEL: formState.printAccel,
    RETRACT_ACCEL: formState.retractAccel,
    TRAVEL_ACCEL: formState.travelAccel,
    FIRST_LAYER_PRINT_ACCEL: formState.firstLayerPrintAccel,
    // advanced
    LAYER_HEIGHT: formState.layerHeight,
    FIRST_LAYER_Z: formState.firstLayerZ,
    TEXT_PRINT_SPEED: formState.textSpeed,
    ROW_FONT_SIZE: formState.rowFontSize,
    SPEED_FONT_SIZE: formState.speedFontSize,
    EXTRUSION_WIDTH: formState.extrusionWidth,
    // Filament diameter is fixed to 1.75 mm; use `FLOW_FACTOR` to tune extrusion
    FILAMENT_DIAMETER: 1.75,
    ROW_GAP: formState.rowGap,
    MARGIN: formState.margin,
    DIST_LABEL_PAD: formState.distLabelPad,
    PRESSURE_ADVANCE: formState.pressureAdvance
  }

  // derived
  cfg.FILAMENT_AREA = filamentArea(cfg.FILAMENT_DIAMETER)
  const baseEPerMm = ePerMmLine(cfg.EXTRUSION_WIDTH, cfg.LAYER_HEIGHT, cfg.FILAMENT_AREA)
  cfg.E_PER_MM = baseEPerMm * cfg.FLOW_FACTOR

  cfg.AVG_RETRACT_DIST = 0.5 * (cfg.MIN_RETRACT_DIST + cfg.MAX_RETRACT_DIST)
  cfg.AVG_RETRACT_SPEED = 0.5 * (cfg.MIN_RETRACT_SPEED + cfg.MAX_RETRACT_SPEED)

  const g = []
  g.push("; Retraction DOE Test")
  g.push("; Generated by retraction_doe_generator (Vite + modular)")
  g.push(`; Retraction distance: ${cfg.MIN_RETRACT_DIST}..${cfg.MAX_RETRACT_DIST} mm`)
  g.push(`; Retraction speed:    ${cfg.MIN_RETRACT_SPEED}..${cfg.MAX_RETRACT_SPEED} mm/s`)
  g.push(`; Row repetitions (parallel lines per parameter): ${cfg.LINES_PER_PARAM}`)
  g.push(`; Flow factor: ${cfg.FLOW_FACTOR.toFixed(3)}`)
  g.push("; Always prints: grid frame + L-shaped label base + labels.")
  g.push("")

  const userStartG = formState.startGcode || START_GCODE_RAW
  const userEndG = formState.endGcode || END_GCODE_RAW
  const startG = applyPlaceholders(userStartG, cfg.BED_TEMP, cfg.HOTEND_TEMP).trim()
  const endG = applyPlaceholders(userEndG, cfg.BED_TEMP, cfg.HOTEND_TEMP).trim()

  if (startG) {
    g.push(startG)
    g.push("")
    if (Number.isFinite(cfg.PRESSURE_ADVANCE)) {
      const paVal = cfg.PRESSURE_ADVANCE
      g.push(`pressure_advance = ${paVal}`)
      g.push(`M572 S${paVal}`)
      g.push("")
    }
    // Emit M204 right after start G-code to set first-layer (or normal) accelerations
    // If FIRST_LAYER_PRINT_ACCEL is provided (not null), always use it; otherwise use PRINT_ACCEL
    let useFirstP = cfg.FIRST_LAYER_PRINT_ACCEL !== null && cfg.FIRST_LAYER_PRINT_ACCEL !== undefined ? cfg.FIRST_LAYER_PRINT_ACCEL : cfg.PRINT_ACCEL
    const useR = Number.isFinite(cfg.RETRACT_ACCEL) ? cfg.RETRACT_ACCEL : ''
    const useT = Number.isFinite(cfg.TRAVEL_ACCEL) ? cfg.TRAVEL_ACCEL : ''
    if (Number.isFinite(useFirstP) || useR !== '' || useT !== '') {
      g.push(`M204 P${useFirstP} R${useR} T${useT}`)
      g.push("")
    }
    // Emit M106 for first layer fan speed (convert percent to 0-255)
    if (Number.isFinite(cfg.FIRST_LAYER_FAN_SPEED)) {
      const fanValue = Math.round((cfg.FIRST_LAYER_FAN_SPEED / 100) * 255)
      g.push(`M106 S${fanValue} ; First layer fan speed ${cfg.FIRST_LAYER_FAN_SPEED}%`)
      g.push("")
    }
  }

  const distLevels = linspace(cfg.ROWS, cfg.MIN_RETRACT_DIST, cfg.MAX_RETRACT_DIST)
  const speedLevels = linspace(cfg.COLS, cfg.MIN_RETRACT_SPEED, cfg.MAX_RETRACT_SPEED)

  const patternWidth = cfg.COLS * (cfg.SEGMENT_LENGTH + cfg.TRAVEL_LENGTH) + cfg.SEGMENT_LENGTH
  const rowBlockHeight = cfg.LINES_PER_PARAM * cfg.EXTRUSION_WIDTH + cfg.ROW_GAP
  // Add extra extrusion width to pattern height to account for DOE offset and ensure clearance at top
  const patternHeight = cfg.ROWS * rowBlockHeight - cfg.ROW_GAP + cfg.EXTRUSION_WIDTH

  const labelGapX = 1.0
  const labelGapY = 1.0

  let maxRowLabelWidth = 0
  distLevels.forEach(d => {
    const w = (d.toFixed(2) + "mm").length * CHAR_ADVANCE * cfg.ROW_FONT_SIZE
    if (w > maxRowLabelWidth) maxRowLabelWidth = w
  })

  const leftLabelArea = maxRowLabelWidth + labelGapX + cfg.DIST_LABEL_PAD
  const bottomLabelMargin = Math.max(cfg.MARGIN, cfg.SPEED_FONT_SIZE + labelGapY)

  const baseWidth = leftLabelArea + patternWidth + cfg.MARGIN
  const baseHeight = bottomLabelMargin + patternHeight

  if (baseWidth > cfg.BED_SIZE_X + 1e-6 || baseHeight > cfg.BED_SIZE_Y + 1e-6) {
    throw new Error(
      `Pattern+labels too big for bed: needs ${baseWidth.toFixed(2)} x ${baseHeight.toFixed(2)} mm, ` +
      `bed is ${cfg.BED_SIZE_X.toFixed(2)} x ${cfg.BED_SIZE_Y.toFixed(2)} mm`
    )
  }

  const baseX0 = (cfg.BED_SIZE_X - baseWidth) / 2.0
  const baseY0 = (cfg.BED_SIZE_Y - baseHeight) / 2.0
  const originX = baseX0 + leftLabelArea
  const originY = baseY0 + bottomLabelMargin

  g.push(`; Centered on bed ${cfg.BED_SIZE_X}x${cfg.BED_SIZE_Y} mm`)
  g.push(`; Base bbox origin: X${baseX0.toFixed(2)} Y${baseY0.toFixed(2)}`)
  g.push(`; Pattern origin:   X${originX.toFixed(2)} Y${originY.toFixed(2)}`)
  g.push(`; Left label area:  ${leftLabelArea.toFixed(2)} mm, Bottom label margin: ${bottomLabelMargin.toFixed(2)} mm`)
  g.push("")

  const zFirst = cfg.FIRST_LAYER_Z
  const zLabels = zFirst + cfg.LAYER_HEIGHT

  g.push(g1Move({ z: zFirst, f: cfg.TRAVEL_SPEED * 60.0, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))

  generateLabelBaseLayer(g, cfg, {
    baseX0, baseY0, originX, originY,
    leftLabelArea, bottomLabelMargin,
    patternWidth, patternHeight, z: zFirst
  })

  generateGridFrameLayer(g, cfg, {
    z: zFirst, originX, originY,
    rows: cfg.ROWS, cols: cfg.COLS,
    rowBlockHeight, patternWidth
  })

  g.push("")
  g.push(`; === DOE Layer 1/${cfg.NUM_DOE_LAYERS} at Z=${zFirst.toFixed(3)}, speed=${cfg.FIRST_LAYER_SPEED}mm/s ===`)
  g.push("G92 E0 ; reset extruder position")
  generateDoeLayer(g, cfg, {
    z: zFirst,
    originX, originY,
    rows: cfg.ROWS,
    cols: cfg.COLS,
    distances: distLevels,
    speeds: speedLevels,
    rowBlockHeight,
    patternWidth,
    printSpeed: cfg.FIRST_LAYER_SPEED
  })

  // Restore normal accelerations and fan speed after first layer (before second-layer labels/printing)
  if (cfg.NUM_DOE_LAYERS >= 2) {
    const normalP = Number.isFinite(cfg.PRINT_ACCEL) ? cfg.PRINT_ACCEL : ''
    const normalR = Number.isFinite(cfg.RETRACT_ACCEL) ? cfg.RETRACT_ACCEL : ''
    const normalT = Number.isFinite(cfg.TRAVEL_ACCEL) ? cfg.TRAVEL_ACCEL : ''
    if (normalP !== '' || normalR !== '' || normalT !== '') {
      g.push("")
      g.push(`M204 P${normalP} R${normalR} T${normalT}`)
      g.push("")
    }
    // Emit M106 for normal fan speed (convert percent to 0-255)
    if (Number.isFinite(cfg.FAN_SPEED)) {
      const fanValue = Math.round((cfg.FAN_SPEED / 100) * 255)
      g.push(`M106 S${fanValue} ; Normal fan speed ${cfg.FAN_SPEED}%`)
      g.push("")
    }
  }

  if (cfg.NUM_DOE_LAYERS >= 2) {
    g.push("")
    g.push("; --- Printing labels for distances and speeds on second layer ---")
    g.push("G92 E0 ; reset extruder position")
    labelPattern(g, cfg, {
      originX, originY,
      baseX0, baseY0,
      rowBlockHeight,
      patternWidth,
      distLevels,
      speedLevels,
      rowFontSize: cfg.ROW_FONT_SIZE,
      speedFontSize: cfg.SPEED_FONT_SIZE,
      labelGapX,
      bottomLabelMargin,
      zLabel: zLabels
    })

    g.push("")
    g.push(`; === DOE Layer 2/${cfg.NUM_DOE_LAYERS} at Z=${zLabels.toFixed(3)}, speed=${cfg.PRINT_SPEED}mm/s ===`)
    generateDoeLayer(g, cfg, {
      z: zLabels,
      originX, originY,
      rows: cfg.ROWS,
      cols: cfg.COLS,
      distances: distLevels,
      speeds: speedLevels,
      rowBlockHeight,
      patternWidth,
      printSpeed: cfg.PRINT_SPEED
    })
  }

  for (let layerIdx = 2; layerIdx < cfg.NUM_DOE_LAYERS; layerIdx++) {
    const z = zFirst + layerIdx * cfg.LAYER_HEIGHT
    g.push("")
    g.push(`; === DOE Layer ${layerIdx+1}/${cfg.NUM_DOE_LAYERS} at Z=${z.toFixed(3)}, speed=${cfg.PRINT_SPEED}mm/s ===`)
    g.push("G92 E0 ; reset extruder position")
    generateDoeLayer(g, cfg, {
      z,
      originX, originY,
      rows: cfg.ROWS,
      cols: cfg.COLS,
      distances: distLevels,
      speeds: speedLevels,
      rowBlockHeight,
      patternWidth,
      printSpeed: cfg.PRINT_SPEED
    })
  }

  // Final retraction before end G-code
  const finalZ = zFirst + (cfg.NUM_DOE_LAYERS - 1) * cfg.LAYER_HEIGHT
  const finalRet = retractLinesAvg(cfg.AVG_RETRACT_DIST, cfg.AVG_RETRACT_SPEED, cfg.Z_HOP, finalZ)
  g.push("")
  g.push("; Final retraction")
  g.push(finalRet.retract)

  if (endG) {
    g.push("")
    g.push(endG)
  }

  return g.join("\n") + "\n"
}

function drawText(gcode, text, x, y, size, z, cfg) {
  const avgRet = retractLinesAvg(cfg.AVG_RETRACT_DIST, cfg.AVG_RETRACT_SPEED, cfg.Z_HOP, z)
  const fPrint = cfg.TEXT_PRINT_SPEED * 60.0
  const fTravel = cfg.TRAVEL_SPEED * 60.0
  const ePerMm = cfg.E_PER_MM
  let cursorX = x

  for (const ch of text) {
    if (ch === " ") {
      cursorX += CHAR_ADVANCE * size
      continue
    }
    const glyph = SIMPLE_FONT[ch]
    if (!glyph) {
      cursorX += CHAR_ADVANCE * size
      continue
    }
    for (const seg of glyph) {
      const [[x1, y1], [x2, y2]] = seg
      const sx = cursorX + x1 * size
      const sy = y + y1 * size
      const ex = cursorX + x2 * size
      const ey = y + y2 * size

      gcode.push("; Label retract before travel")
      gcode.push(avgRet.retract)
      gcode.push(g1Move({ x: sx, y: sy, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
      gcode.push("; Label deretract before stroke")
      gcode.push(avgRet.deretract)

      const length = Math.hypot(ex - sx, ey - sy)
      const e = length * ePerMm
      gcode.push(g1Move({ x: ex, y: ey, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
    }
    cursorX += CHAR_ADVANCE * size
  }
}

function generateLabelBaseLayer(gcode, cfg, params) {
  const {
    baseX0, baseY0, originX, originY,
    leftLabelArea, bottomLabelMargin,
    patternWidth, patternHeight, z
  } = params

  gcode.push(`; --- L-shaped label base at Z=${z.toFixed(3)} ---`)
  const fPrint = cfg.FIRST_LAYER_SPEED * 60.0
  const fTravel = cfg.TRAVEL_SPEED * 60.0
  const lineSpacing = cfg.EXTRUSION_WIDTH
  const ePerMm = cfg.E_PER_MM

  // L-shape dimensions: vertical bar (left) + horizontal bar (bottom) connected at corner
  const leftWidth = leftLabelArea
  const leftHeight = patternHeight
  const leftX0 = baseX0
  const leftY0 = originY
  
  const bottomWidth = patternWidth
  const bottomHeight = bottomLabelMargin
  const bottomX0 = originX
  const bottomY0 = baseY0
  
  // Corner piece to connect left and bottom
  const cornerWidth = leftLabelArea
  const cornerHeight = bottomLabelMargin
  const cornerX0 = baseX0
  const cornerY0 = baseY0

  // Calculate the bounding box of the entire L-shape for the perimeter
  // Shrink by one extrusion width to avoid overlap with grid frame
  const gap = cfg.EXTRUSION_WIDTH
  const lShapeMinX = baseX0
  const lShapeMinY = baseY0
  const lShapeMaxX = originX + patternWidth
  const lShapeMaxY = originY + patternHeight
  
  // Inner corner of the L (where it meets the grid) - moved inward by gap
  const innerCornerX = originX - gap
  const innerCornerY = originY - gap

  // Print perimeter first (single outline around entire L-shape)
  gcode.push(`; L-shape perimeter for adhesion (offset by ${gap.toFixed(3)}mm from grid)`)
  gcode.push(g1Move({ x: lShapeMinX, y: lShapeMinY, z, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  
  // Draw perimeter clockwise starting from bottom-left corner
  let length, e
  // Bottom edge
  length = lShapeMaxX - lShapeMinX
  e = length * ePerMm
  gcode.push(g1Move({ x: lShapeMaxX, y: lShapeMinY, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  // Right edge of bottom bar (up to the gap before grid)
  length = innerCornerY - lShapeMinY
  e = length * ePerMm
  gcode.push(g1Move({ x: lShapeMaxX, y: innerCornerY, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  // Step inward at the L corner (left to the gap before grid)
  length = lShapeMaxX - innerCornerX
  e = length * ePerMm
  gcode.push(g1Move({ x: innerCornerX, y: innerCornerY, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  // Up the inner vertical edge
  length = lShapeMaxY - innerCornerY
  e = length * ePerMm
  gcode.push(g1Move({ x: innerCornerX, y: lShapeMaxY, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  // Top edge
  length = innerCornerX - lShapeMinX
  e = length * ePerMm
  gcode.push(g1Move({ x: lShapeMinX, y: lShapeMaxY, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  // Left edge back to start
  length = lShapeMaxY - lShapeMinY
  e = length * ePerMm
  gcode.push(g1Move({ x: lShapeMinX, y: lShapeMinY, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))

  // Fill the three rectangles that make up the L-shape
  function fillRect(x0, y0, width, height, label) {
    if (width <= 0 || height <= 0) return
    gcode.push(`; ${label}: X${x0.toFixed(3)} Y${y0.toFixed(3)} W${width.toFixed(3)} H${height.toFixed(3)}`)
    gcode.push(g1Move({ x: x0, y: y0, z, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
    // Since height is now an exact multiple of lineSpacing, we need exactly (height / lineSpacing) lines
    const nLines = Math.round(height / lineSpacing)
    for (let i = 0; i < nLines; i++) {
      const y = y0 + i * lineSpacing
      const xStart = (i % 2 === 0) ? x0 : x0 + width
      const xEnd = (i % 2 === 0) ? x0 + width : x0
      gcode.push(g1Move({ x: xStart, y, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
      const length = Math.abs(xEnd - xStart)
      const e = length * ePerMm
      gcode.push(g1Move({ x: xEnd, y, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
    }
  }

  // Shrink fill areas inward by gap on all sides to avoid overlap with perimeter
  // Corner and bottom bar need gap on top and bottom
  const cornerFillHeight = Math.floor((bottomLabelMargin - 2*gap) / lineSpacing) * lineSpacing
  const bottomFillHeight = cornerFillHeight  // Same height as corner
  
  // Left bar: extends from top of corner fill up to top of pattern
  // Calculate where corner fill ends
  const cornerFillTop = cornerY0 + gap + cornerFillHeight
  const leftBarStartY = cornerFillTop
  const leftBarHeight = (originY + patternHeight) - leftBarStartY
  const leftFillHeight = Math.ceil(leftBarHeight / lineSpacing) * lineSpacing
  
  // Bottom-left corner piece (inset by gap on all sides)
  fillRect(cornerX0 + gap, cornerY0 + gap, cornerWidth - 2*gap, cornerFillHeight, "L-corner fill")
  // Left vertical bar (inset from left and right, starts where corner ends)
  fillRect(leftX0 + gap, leftBarStartY, leftWidth - 2*gap, leftFillHeight, "L-left fill")
  // Bottom horizontal bar (inset from bottom and top, starts at originX)
  fillRect(bottomX0, bottomY0 + gap, bottomWidth - gap, bottomFillHeight, "L-bottom fill")
}

function generateGridFrameLayer(gcode, cfg, params) {
  const { z, originX, originY, rows, cols, rowBlockHeight, patternWidth } = params
  gcode.push(`; --- Grid frame layer at Z=${z.toFixed(3)} ---`)
  const fPrint = cfg.FIRST_LAYER_SPEED * 60.0
  const fTravel = cfg.TRAVEL_SPEED * 60.0
  const ePerMm = cfg.E_PER_MM

  // Add extra extrusion width to pattern height to match the extended frame (same as main calculation)
  const patternHeight = rows * rowBlockHeight - cfg.ROW_GAP + cfg.EXTRUSION_WIDTH
  const cellSpanX = cfg.SEGMENT_LENGTH + cfg.TRAVEL_LENGTH

  const xMin = originX
  const xMax = originX + patternWidth
  const yMin = originY
  const yMax = originY + patternHeight

  const avgRet = retractLinesAvg(cfg.AVG_RETRACT_DIST, cfg.AVG_RETRACT_SPEED, cfg.Z_HOP, z)

  gcode.push("; Grid frame: outer rectangle")
  gcode.push("; Grid retract before travel to outer start")
  gcode.push(avgRet.retract)
  gcode.push(g1Move({ x: xMin, y: yMin, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  gcode.push("; Grid deretract before outer rectangle")
  gcode.push(avgRet.deretract)

  let length, e

  length = xMax - xMin
  e = length * ePerMm
  gcode.push(g1Move({ x: xMax, y: yMin, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  length = yMax - yMin
  e = length * ePerMm
  gcode.push(g1Move({ x: xMax, y: yMax, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  length = xMax - xMin
  e = length * ePerMm
  gcode.push(g1Move({ x: xMin, y: yMax, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  length = yMax - yMin
  e = length * ePerMm
  gcode.push(g1Move({ x: xMin, y: yMin, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))

  gcode.push("; Grid frame: vertical lines between columns")
  for (let c = 1; c < cols; c++) {
    const x = originX + c * cellSpanX
    gcode.push("; Grid retract before vertical travel")
    gcode.push(avgRet.retract)
    gcode.push(g1Move({ x, y: yMin, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
    gcode.push("; Grid deretract before vertical line")
    gcode.push(avgRet.deretract)
    length = yMax - yMin
    e = length * ePerMm
    gcode.push(g1Move({ x, y: yMax, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  }

  gcode.push("; Grid frame: horizontal lines between rows")
  for (let r = 1; r < rows; r++) {
    const y = originY + r * rowBlockHeight
    gcode.push("; Grid retract before horizontal travel")
    gcode.push(avgRet.retract)
    gcode.push(g1Move({ x: xMin, y, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
    gcode.push("; Grid deretract before horizontal line")
    gcode.push(avgRet.deretract)
    length = xMax - xMin
    e = length * ePerMm
    gcode.push(g1Move({ x: xMax, y, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  }
}

function generateDoeLayer(gcode, cfg, params) {
  const {
    z, originX, originY, rows, cols,
    distances, speeds, rowBlockHeight, patternWidth, printSpeed
  } = params

  gcode.push(`; --- DOE layer at Z=${z.toFixed(3)} ---`)
  const fPrint = printSpeed * 60.0
  const fTravel = cfg.TRAVEL_SPEED * 60.0
  const ePerMm = cfg.E_PER_MM

  // Offset DOE patterns up by one extrusion width to avoid overlapping with grid frame
  const doeYOffset = cfg.EXTRUSION_WIDTH
  
  for (let r = 0; r < rows; r++) {
    const dist = distances[r]
    const baseYRow = originY + r * rowBlockHeight + doeYOffset
    gcode.push(`; ===== Distance row ${r+1}/${rows}, dist=${dist.toFixed(3)}mm =====`)

    let xCurrent = originX

    for (let rep = 0; rep < cfg.LINES_PER_PARAM; rep++) {
      const repDir = (rep % 2 === 0) ? 1.0 : -1.0
      const yLine = baseYRow + rep * cfg.EXTRUSION_WIDTH
      if (rep === 0) xCurrent = originX

      gcode.push(g1Move({ x: xCurrent, y: yLine, z, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
      gcode.push(`; Row ${r+1}/${rows}, repetition ${rep+1}/${cfg.LINES_PER_PARAM}, dist=${dist.toFixed(3)}mm, dir=${repDir>0?"L->R":"R->L"}`)

      const colOrder = (repDir > 0)
        ? [...Array(cols).keys()]
        : [...Array(cols).keys()].reverse()

      for (const c of colOrder) {
        const speed = speeds[c]
        const ret = retractLinesDoe(dist, speed, cfg.Z_HOP, z)
        gcode.push(`;   Col ${c+1}/${cols}, speed=${speed.toFixed(1)}mm/s`)

        let xExtrudeEnd = xCurrent + repDir * cfg.SEGMENT_LENGTH
        let length = Math.abs(xExtrudeEnd - xCurrent)
        let e = length * ePerMm
        gcode.push(g1Move({ x: xExtrudeEnd, y: yLine, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
        xCurrent = xExtrudeEnd

        gcode.push(ret.retract)

        let xTravelEnd = xCurrent + repDir * cfg.TRAVEL_LENGTH
        gcode.push(g1Move({ x: xTravelEnd, y: yLine, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
        xCurrent = xTravelEnd

        gcode.push(ret.deretract)
      }

      gcode.push(";   Final normal print section at end of repetition line")
      const xFinal = xCurrent + repDir * cfg.SEGMENT_LENGTH
      const lengthFinal = Math.abs(xFinal - xCurrent)
      const eFinal = lengthFinal * ePerMm
      gcode.push(g1Move({ x: xFinal, y: yLine, e: eFinal, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
      xCurrent = xFinal
    }
  }
}

function labelPattern(gcode, cfg, params) {
  const {
    originX, originY, baseX0, baseY0,
    rowBlockHeight, patternWidth,
    distLevels, speedLevels,
    rowFontSize, speedFontSize,
    labelGapX, bottomLabelMargin, zLabel
  } = params

  distLevels.forEach((dist, r) => {
    const text = dist.toFixed(2) + "mm"
    const textWidth = text.length * CHAR_ADVANCE * rowFontSize
    const yCenter = originY + r * rowBlockHeight + rowBlockHeight / 2.0
    const yText = yCenter - rowFontSize / 2.0
    const xTextNominal = originX - labelGapX - textWidth
    const minXText = baseX0 + cfg.DIST_LABEL_PAD
    const xText = Math.max(xTextNominal, minXText)

    gcode.push(`; Text label for distance row ${r+1}: ${text}`)
    drawText(gcode, text, xText, yText, rowFontSize, zLabel, cfg)
  })

  const cellSpanX = cfg.SEGMENT_LENGTH + cfg.TRAVEL_LENGTH
  const yTextBase = baseY0 + (bottomLabelMargin - speedFontSize) / 2.0

  speedLevels.forEach((speed, c) => {
    const text = speed.toFixed(0) + "mm/s"
    const approxWidth = text.length * CHAR_ADVANCE * speedFontSize
    const xCellStart = originX + c * cellSpanX
    const xCenterTravel = xCellStart + cfg.SEGMENT_LENGTH + cfg.TRAVEL_LENGTH / 2.0
    const xText = xCenterTravel - approxWidth / 2.0

    gcode.push(`; Text label for speed col ${c+1}: ${text}`)
    drawText(gcode, text, xText, yTextBase, speedFontSize, zLabel, cfg)
  })
}
