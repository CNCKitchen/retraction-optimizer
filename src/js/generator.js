import { CHAR_ADVANCE, SIMPLE_FONT, START_GCODE_RAW, END_GCODE_RAW } from './constants.js'
import {
  linspace, filamentArea, ePerMmLine, g1Move, applyPlaceholders,
  retractLinesDoe, retractLinesAvg
} from './helpers.js'

export function generateGcodeFromForm(formState) {
  const cfg = {
    // basic form values
    BED_SIZE_X: formState.bedX,
    BED_SIZE_Y: formState.bedY,
    MIN_RETRACT_DIST: formState.minDist,
    MAX_RETRACT_DIST: formState.maxDist,
    MIN_RETRACT_SPEED: formState.minSpeed,
    MAX_RETRACT_SPEED: formState.maxSpeed,
    ROWS: formState.rows,
    COLS: formState.cols,
    LINES_PER_PARAM: formState.linesPerParam,
    NUM_DOE_LAYERS: formState.numLayers,
    SEGMENT_LENGTH: formState.segLen,
    TRAVEL_LENGTH: formState.travelLen,
    FLOW_FACTOR: formState.flowFactor,
    BED_TEMP: formState.bedTemp,
    HOTEND_TEMP: formState.hotendTemp,
    FIRST_LAYER_SPEED: formState.firstLayerSpeed,
    PRINT_SPEED: formState.printSpeed,
    TRAVEL_SPEED: formState.travelSpeed,
    // accelerations (mm/s^2)
    PRINT_ACCEL: formState.printAccel,
    RETRACT_ACCEL: formState.retractAccel,
    TRAVEL_ACCEL: formState.travelAccel,
    FIRST_LAYER_PRINT_ACCEL: formState.firstLayerPrintAccel,
    // advanced
    LAYER_HEIGHT: formState.layerHeight,
    FIRST_LAYER_Z: formState.firstLayerZ,
    TEXT_PRINT_SPEED: formState.textSpeed,
    ROW_FONT_SIZE: formState.rowFontSize,
    SPEED_FONT_SIZE: formState.speedFontSize,
    EXTRUSION_WIDTH: formState.extrusionWidth,
    // Filament diameter is fixed to 1.75 mm; use `FLOW_FACTOR` to tune extrusion
    FILAMENT_DIAMETER: 1.75,
    ROW_GAP: formState.rowGap,
    MARGIN: formState.margin,
    DIST_LABEL_PAD: formState.distLabelPad,
    PRESSURE_ADVANCE: formState.pressureAdvance
  }

  // derived
  cfg.FILAMENT_AREA = filamentArea(cfg.FILAMENT_DIAMETER)
  const baseEPerMm = ePerMmLine(cfg.EXTRUSION_WIDTH, cfg.LAYER_HEIGHT, cfg.FILAMENT_AREA)
  cfg.E_PER_MM = baseEPerMm * cfg.FLOW_FACTOR

  cfg.AVG_RETRACT_DIST = 0.5 * (cfg.MIN_RETRACT_DIST + cfg.MAX_RETRACT_DIST)
  cfg.AVG_RETRACT_SPEED = 0.5 * (cfg.MIN_RETRACT_SPEED + cfg.MAX_RETRACT_SPEED)

  const g = []
  g.push("; Retraction DOE Test")
  g.push("; Generated by retraction_doe_generator (Vite + modular)")
  g.push(`; Retraction distance: ${cfg.MIN_RETRACT_DIST}..${cfg.MAX_RETRACT_DIST} mm`)
  g.push(`; Retraction speed:    ${cfg.MIN_RETRACT_SPEED}..${cfg.MAX_RETRACT_SPEED} mm/s`)
  g.push(`; Row repetitions (parallel lines per parameter): ${cfg.LINES_PER_PARAM}`)
  g.push(`; Flow factor: ${cfg.FLOW_FACTOR.toFixed(3)}`)
  g.push("; Always prints: grid frame + L-shaped label base + labels.")
  g.push("")

  const userStartG = formState.startGcode || START_GCODE_RAW
  const userEndG = formState.endGcode || END_GCODE_RAW
  const startG = applyPlaceholders(userStartG, cfg.BED_TEMP, cfg.HOTEND_TEMP).trim()
  const endG = applyPlaceholders(userEndG, cfg.BED_TEMP, cfg.HOTEND_TEMP).trim()

  if (startG) {
    g.push(startG)
    g.push("")
    if (Number.isFinite(cfg.PRESSURE_ADVANCE)) {
      const paVal = cfg.PRESSURE_ADVANCE
      g.push(`pressure_advance = ${paVal}`)
      g.push(`M572 S${paVal}`)
      g.push("")
    }
    // Emit M204 right after start G-code to set first-layer (or normal) accelerations
    // If FIRST_LAYER_PRINT_ACCEL is provided (not null), always use it; otherwise use PRINT_ACCEL
    let useFirstP = cfg.FIRST_LAYER_PRINT_ACCEL !== null && cfg.FIRST_LAYER_PRINT_ACCEL !== undefined ? cfg.FIRST_LAYER_PRINT_ACCEL : cfg.PRINT_ACCEL
    const useR = Number.isFinite(cfg.RETRACT_ACCEL) ? cfg.RETRACT_ACCEL : ''
    const useT = Number.isFinite(cfg.TRAVEL_ACCEL) ? cfg.TRAVEL_ACCEL : ''
    if (Number.isFinite(useFirstP) || useR !== '' || useT !== '') {
      g.push(`M204 P${useFirstP} R${useR} T${useT}`)
      g.push("")
    }
  }

  const distLevels = linspace(cfg.ROWS, cfg.MIN_RETRACT_DIST, cfg.MAX_RETRACT_DIST)
  const speedLevels = linspace(cfg.COLS, cfg.MIN_RETRACT_SPEED, cfg.MAX_RETRACT_SPEED)

  const patternWidth = cfg.COLS * (cfg.SEGMENT_LENGTH + cfg.TRAVEL_LENGTH) + cfg.SEGMENT_LENGTH
  const rowBlockHeight = cfg.LINES_PER_PARAM * cfg.EXTRUSION_WIDTH + cfg.ROW_GAP
  const patternHeight = cfg.ROWS * rowBlockHeight - cfg.ROW_GAP

  const labelGapX = 1.0
  const labelGapY = 1.0

  let maxRowLabelWidth = 0
  distLevels.forEach(d => {
    const w = (d.toFixed(2) + "mm").length * CHAR_ADVANCE * cfg.ROW_FONT_SIZE
    if (w > maxRowLabelWidth) maxRowLabelWidth = w
  })

  const leftLabelArea = maxRowLabelWidth + labelGapX + cfg.DIST_LABEL_PAD
  const bottomLabelMargin = Math.max(cfg.MARGIN, cfg.SPEED_FONT_SIZE + labelGapY)

  const baseWidth = leftLabelArea + patternWidth + cfg.MARGIN
  const baseHeight = bottomLabelMargin + patternHeight

  if (baseWidth > cfg.BED_SIZE_X + 1e-6 || baseHeight > cfg.BED_SIZE_Y + 1e-6) {
    throw new Error(
      `Pattern+labels too big for bed: needs ${baseWidth.toFixed(2)} x ${baseHeight.toFixed(2)} mm, ` +
      `bed is ${cfg.BED_SIZE_X.toFixed(2)} x ${cfg.BED_SIZE_Y.toFixed(2)} mm`
    )
  }

  const baseX0 = (cfg.BED_SIZE_X - baseWidth) / 2.0
  const baseY0 = (cfg.BED_SIZE_Y - baseHeight) / 2.0
  const originX = baseX0 + leftLabelArea
  const originY = baseY0 + bottomLabelMargin

  g.push(`; Centered on bed ${cfg.BED_SIZE_X}x${cfg.BED_SIZE_Y} mm`)
  g.push(`; Base bbox origin: X${baseX0.toFixed(2)} Y${baseY0.toFixed(2)}`)
  g.push(`; Pattern origin:   X${originX.toFixed(2)} Y${originY.toFixed(2)}`)
  g.push(`; Left label area:  ${leftLabelArea.toFixed(2)} mm, Bottom label margin: ${bottomLabelMargin.toFixed(2)} mm`)
  g.push("")

  const zFirst = cfg.FIRST_LAYER_Z
  const zLabels = zFirst + cfg.LAYER_HEIGHT

  g.push(g1Move({ z: zFirst, f: cfg.TRAVEL_SPEED * 60.0, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))

  generateLabelBaseLayer(g, cfg, {
    baseX0, baseY0, originX, originY,
    leftLabelArea, bottomLabelMargin,
    patternWidth, patternHeight, z: zFirst
  })

  generateGridFrameLayer(g, cfg, {
    z: zFirst, originX, originY,
    rows: cfg.ROWS, cols: cfg.COLS,
    rowBlockHeight, patternWidth
  })

  g.push("")
  g.push(`; === DOE Layer 1/${cfg.NUM_DOE_LAYERS} at Z=${zFirst.toFixed(3)}, speed=${cfg.FIRST_LAYER_SPEED}mm/s ===`)
  generateDoeLayer(g, cfg, {
    z: zFirst,
    originX, originY,
    rows: cfg.ROWS,
    cols: cfg.COLS,
    distances: distLevels,
    speeds: speedLevels,
    rowBlockHeight,
    patternWidth,
    printSpeed: cfg.FIRST_LAYER_SPEED
  })

  // Restore normal accelerations after first layer (before second-layer labels/printing)
  if (cfg.NUM_DOE_LAYERS >= 2) {
    const normalP = Number.isFinite(cfg.PRINT_ACCEL) ? cfg.PRINT_ACCEL : ''
    const normalR = Number.isFinite(cfg.RETRACT_ACCEL) ? cfg.RETRACT_ACCEL : ''
    const normalT = Number.isFinite(cfg.TRAVEL_ACCEL) ? cfg.TRAVEL_ACCEL : ''
    if (normalP !== '' || normalR !== '' || normalT !== '') {
      g.push("")
      g.push(`M204 P${normalP} R${normalR} T${normalT}`)
      g.push("")
    }
  }

  if (cfg.NUM_DOE_LAYERS >= 2) {
    g.push("")
    g.push("; --- Printing labels for distances and speeds on second layer ---")
    labelPattern(g, cfg, {
      originX, originY,
      baseX0, baseY0,
      rowBlockHeight,
      patternWidth,
      distLevels,
      speedLevels,
      rowFontSize: cfg.ROW_FONT_SIZE,
      speedFontSize: cfg.SPEED_FONT_SIZE,
      labelGapX,
      bottomLabelMargin,
      zLabel: zLabels
    })

    g.push("")
    g.push(`; === DOE Layer 2/${cfg.NUM_DOE_LAYERS} at Z=${zLabels.toFixed(3)}, speed=${cfg.PRINT_SPEED}mm/s ===`)
    generateDoeLayer(g, cfg, {
      z: zLabels,
      originX, originY,
      rows: cfg.ROWS,
      cols: cfg.COLS,
      distances: distLevels,
      speeds: speedLevels,
      rowBlockHeight,
      patternWidth,
      printSpeed: cfg.PRINT_SPEED
    })
  }

  for (let layerIdx = 2; layerIdx < cfg.NUM_DOE_LAYERS; layerIdx++) {
    const z = zFirst + layerIdx * cfg.LAYER_HEIGHT
    g.push("")
    g.push(`; === DOE Layer ${layerIdx+1}/${cfg.NUM_DOE_LAYERS} at Z=${z.toFixed(3)}, speed=${cfg.PRINT_SPEED}mm/s ===`)
    generateDoeLayer(g, cfg, {
      z,
      originX, originY,
      rows: cfg.ROWS,
      cols: cfg.COLS,
      distances: distLevels,
      speeds: speedLevels,
      rowBlockHeight,
      patternWidth,
      printSpeed: cfg.PRINT_SPEED
    })
  }

  if (endG) {
    g.push("")
    g.push(endG)
  }

  return g.join("\n") + "\n"
}

function drawText(gcode, text, x, y, size, z, cfg, avgRet) {
  const fPrint = cfg.TEXT_PRINT_SPEED * 60.0
  const fTravel = cfg.TRAVEL_SPEED * 60.0
  const ePerMm = cfg.E_PER_MM
  let cursorX = x

  for (const ch of text) {
    if (ch === " ") {
      cursorX += CHAR_ADVANCE * size
      continue
    }
    const glyph = SIMPLE_FONT[ch]
    if (!glyph) {
      cursorX += CHAR_ADVANCE * size
      continue
    }
    for (const seg of glyph) {
      const [[x1, y1], [x2, y2]] = seg
      const sx = cursorX + x1 * size
      const sy = y + y1 * size
      const ex = cursorX + x2 * size
      const ey = y + y2 * size

      gcode.push("; Label retract before travel")
      gcode.push(avgRet.retract)
      gcode.push(g1Move({ x: sx, y: sy, z, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
      gcode.push("; Label deretract before stroke")
      gcode.push(avgRet.deretract)

      const length = Math.hypot(ex - sx, ey - sy)
      const e = length * ePerMm
      gcode.push(g1Move({ x: ex, y: ey, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
    }
    cursorX += CHAR_ADVANCE * size
  }
}

function generateLabelBaseLayer(gcode, cfg, params) {
  const {
    baseX0, baseY0, originX, originY,
    leftLabelArea, bottomLabelMargin,
    patternWidth, patternHeight, z
  } = params

  gcode.push(`; --- L-shaped label base at Z=${z.toFixed(3)} ---`)
  const fPrint = cfg.FIRST_LAYER_SPEED * 60.0
  const fTravel = cfg.TRAVEL_SPEED * 60.0
  const lineSpacing = cfg.EXTRUSION_WIDTH
  const ePerMm = cfg.E_PER_MM

  // L-shape dimensions: vertical bar (left) + horizontal bar (bottom) connected at corner
  const leftWidth = leftLabelArea
  const leftHeight = patternHeight
  const leftX0 = baseX0
  const leftY0 = originY
  
  const bottomWidth = patternWidth
  const bottomHeight = bottomLabelMargin
  const bottomX0 = originX
  const bottomY0 = baseY0
  
  // Corner piece to connect left and bottom
  const cornerWidth = leftLabelArea
  const cornerHeight = bottomLabelMargin
  const cornerX0 = baseX0
  const cornerY0 = baseY0

  // Calculate the bounding box of the entire L-shape for the perimeter
  const lShapeMinX = baseX0
  const lShapeMinY = baseY0
  const lShapeMaxX = originX + patternWidth
  const lShapeMaxY = originY + patternHeight

  // Print perimeter first (single outline around entire L-shape)
  gcode.push(`; L-shape perimeter for adhesion`)
  gcode.push(g1Move({ x: lShapeMinX, y: lShapeMinY, z, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  
  // Draw perimeter clockwise starting from bottom-left corner
  let length, e
  // Bottom edge
  length = lShapeMaxX - lShapeMinX
  e = length * ePerMm
  gcode.push(g1Move({ x: lShapeMaxX, y: lShapeMinY, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  // Right edge of bottom bar
  length = originY - lShapeMinY
  e = length * ePerMm
  gcode.push(g1Move({ x: lShapeMaxX, y: originY, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  // Step inward at the L corner
  length = lShapeMaxX - originX
  e = length * ePerMm
  gcode.push(g1Move({ x: originX, y: originY, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  // Up the inner vertical edge
  length = lShapeMaxY - originY
  e = length * ePerMm
  gcode.push(g1Move({ x: originX, y: lShapeMaxY, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  // Top edge
  length = originX - lShapeMinX
  e = length * ePerMm
  gcode.push(g1Move({ x: lShapeMinX, y: lShapeMaxY, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  // Left edge back to start
  length = lShapeMaxY - lShapeMinY
  e = length * ePerMm
  gcode.push(g1Move({ x: lShapeMinX, y: lShapeMinY, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))

  // Fill the three rectangles that make up the L-shape
  function fillRect(x0, y0, width, height, label) {
    if (width <= 0 || height <= 0) return
    gcode.push(`; ${label}: X${x0.toFixed(3)} Y${y0.toFixed(3)} W${width.toFixed(3)} H${height.toFixed(3)}`)
    gcode.push(g1Move({ x: x0, y: y0, z, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
    const nLines = Math.floor(height / lineSpacing) + 1
    for (let i = 0; i < nLines; i++) {
      const y = y0 + i * lineSpacing
      const xStart = (i % 2 === 0) ? x0 : x0 + width
      const xEnd = (i % 2 === 0) ? x0 + width : x0
      gcode.push(g1Move({ x: xStart, y, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
      const length = Math.abs(xEnd - xStart)
      const e = length * ePerMm
      gcode.push(g1Move({ x: xEnd, y, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
    }
  }

  // Fill bottom-left corner piece
  fillRect(cornerX0, cornerY0, cornerWidth, cornerHeight, "L-corner fill")
  // Fill left vertical bar
  fillRect(leftX0, leftY0, leftWidth, leftHeight, "L-left fill")
  // Fill bottom horizontal bar
  fillRect(bottomX0, bottomY0, bottomWidth, bottomHeight, "L-bottom fill")
}

function generateGridFrameLayer(gcode, cfg, params) {
  const { z, originX, originY, rows, cols, rowBlockHeight, patternWidth } = params
  gcode.push(`; --- Grid frame layer at Z=${z.toFixed(3)} ---`)
  const fPrint = cfg.FIRST_LAYER_SPEED * 60.0
  const fTravel = cfg.TRAVEL_SPEED * 60.0
  const ePerMm = cfg.E_PER_MM

  const patternHeight = rows * rowBlockHeight - cfg.ROW_GAP
  const cellSpanX = cfg.SEGMENT_LENGTH + cfg.TRAVEL_LENGTH

  const xMin = originX
  const xMax = originX + patternWidth
  const yMin = originY
  const yMax = originY + patternHeight

  const avgRet = retractLinesAvg(cfg.AVG_RETRACT_DIST, cfg.AVG_RETRACT_SPEED)

  gcode.push("; Grid frame: outer rectangle")
  gcode.push("; Grid retract before travel to outer start")
  gcode.push(avgRet.retract)
  gcode.push(g1Move({ x: xMin, y: yMin, z, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  gcode.push("; Grid deretract before outer rectangle")
  gcode.push(avgRet.deretract)

  let length, e

  length = xMax - xMin
  e = length * ePerMm
  gcode.push(g1Move({ x: xMax, y: yMin, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  length = yMax - yMin
  e = length * ePerMm
  gcode.push(g1Move({ x: xMax, y: yMax, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  length = xMax - xMin
  e = length * ePerMm
  gcode.push(g1Move({ x: xMin, y: yMax, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  length = yMax - yMin
  e = length * ePerMm
  gcode.push(g1Move({ x: xMin, y: yMin, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))

  gcode.push("; Grid frame: vertical lines between columns")
  for (let c = 1; c < cols; c++) {
    const x = originX + c * cellSpanX
    gcode.push("; Grid retract before vertical travel")
    gcode.push(avgRet.retract)
    gcode.push(g1Move({ x, y: yMin, z, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
    gcode.push("; Grid deretract before vertical line")
    gcode.push(avgRet.deretract)
    length = yMax - yMin
    e = length * ePerMm
    gcode.push(g1Move({ x, y: yMax, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  }

  gcode.push("; Grid frame: horizontal lines between rows")
  for (let r = 1; r < rows; r++) {
    const y = originY + r * rowBlockHeight
    gcode.push("; Grid retract before horizontal travel")
    gcode.push(avgRet.retract)
    gcode.push(g1Move({ x: xMin, y, z, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
    gcode.push("; Grid deretract before horizontal line")
    gcode.push(avgRet.deretract)
    length = xMax - xMin
    e = length * ePerMm
    gcode.push(g1Move({ x: xMax, y, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
  }
}

function generateDoeLayer(gcode, cfg, params) {
  const {
    z, originX, originY, rows, cols,
    distances, speeds, rowBlockHeight, patternWidth, printSpeed
  } = params

  gcode.push(`; --- DOE layer at Z=${z.toFixed(3)} ---`)
  const fPrint = printSpeed * 60.0
  const fTravel = cfg.TRAVEL_SPEED * 60.0
  const ePerMm = cfg.E_PER_MM

  for (let r = 0; r < rows; r++) {
    const dist = distances[r]
    const baseYRow = originY + r * rowBlockHeight
    gcode.push(`; ===== Distance row ${r+1}/${rows}, dist=${dist.toFixed(3)}mm =====`)

    let xCurrent = originX

    for (let rep = 0; rep < cfg.LINES_PER_PARAM; rep++) {
      const repDir = (rep % 2 === 0) ? 1.0 : -1.0
      const yLine = baseYRow + rep * cfg.EXTRUSION_WIDTH
      if (rep === 0) xCurrent = originX

      gcode.push(g1Move({ x: xCurrent, y: yLine, z, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
      gcode.push(`; Row ${r+1}/${rows}, repetition ${rep+1}/${cfg.LINES_PER_PARAM}, dist=${dist.toFixed(3)}mm, dir=${repDir>0?"L->R":"R->L"}`)

      const colOrder = (repDir > 0)
        ? [...Array(cols).keys()]
        : [...Array(cols).keys()].reverse()

      for (const c of colOrder) {
        const speed = speeds[c]
        const ret = retractLinesDoe(dist, speed)
        gcode.push(`;   Col ${c+1}/${cols}, speed=${speed.toFixed(1)}mm/s`)

        let xExtrudeEnd = xCurrent + repDir * cfg.SEGMENT_LENGTH
        let length = Math.abs(xExtrudeEnd - xCurrent)
        let e = length * ePerMm
        gcode.push(g1Move({ x: xExtrudeEnd, y: yLine, e, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
        xCurrent = xExtrudeEnd

        gcode.push(ret.retract)

        let xTravelEnd = xCurrent + repDir * cfg.TRAVEL_LENGTH
        gcode.push(g1Move({ x: xTravelEnd, y: yLine, f: fTravel, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
        xCurrent = xTravelEnd

        gcode.push(ret.deretract)
      }

      gcode.push(";   Final normal print section at end of repetition line")
      const xFinal = xCurrent + repDir * cfg.SEGMENT_LENGTH
      const lengthFinal = Math.abs(xFinal - xCurrent)
      const eFinal = lengthFinal * ePerMm
      gcode.push(g1Move({ x: xFinal, y: yLine, e: eFinal, f: fPrint, bedX: cfg.BED_SIZE_X, bedY: cfg.BED_SIZE_Y }))
      xCurrent = xFinal
    }
  }
}

function labelPattern(gcode, cfg, params) {
  const {
    originX, originY, baseX0, baseY0,
    rowBlockHeight, patternWidth,
    distLevels, speedLevels,
    rowFontSize, speedFontSize,
    labelGapX, bottomLabelMargin, zLabel
  } = params

  const avgRet = retractLinesAvg(cfg.AVG_RETRACT_DIST, cfg.AVG_RETRACT_SPEED)

  distLevels.forEach((dist, r) => {
    const text = dist.toFixed(2) + "mm"
    const textWidth = text.length * CHAR_ADVANCE * rowFontSize
    const yCenter = originY + r * rowBlockHeight + rowBlockHeight / 2.0
    const yText = yCenter - rowFontSize / 2.0
    const xTextNominal = originX - labelGapX - textWidth
    const minXText = baseX0 + cfg.DIST_LABEL_PAD
    const xText = Math.max(xTextNominal, minXText)

    gcode.push(`; Text label for distance row ${r+1}: ${text}`)
    drawText(gcode, text, xText, yText, rowFontSize, zLabel, cfg, avgRet)
  })

  const cellSpanX = cfg.SEGMENT_LENGTH + cfg.TRAVEL_LENGTH
  const yTextBase = baseY0 + (bottomLabelMargin - speedFontSize) / 2.0

  speedLevels.forEach((speed, c) => {
    const text = speed.toFixed(0) + "mm/s"
    const approxWidth = text.length * CHAR_ADVANCE * speedFontSize
    const xCellStart = originX + c * cellSpanX
    const xCenterTravel = xCellStart + cfg.SEGMENT_LENGTH + cfg.TRAVEL_LENGTH / 2.0
    const xText = xCenterTravel - approxWidth / 2.0

    gcode.push(`; Text label for speed col ${c+1}: ${text}`)
    drawText(gcode, text, xText, yTextBase, speedFontSize, zLabel, cfg, avgRet)
  })
}
